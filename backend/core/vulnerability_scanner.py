"""
Vulnerability Scanner - Facade (Backwards Compatible)

This module maintains the original public interface while delegating
to the decoupled backend modules:
- ScanRouter: Request routing and orchestration
- DatabaseScanner: Fast path database queries (Path A)
- AIAnalyzer: LLM inference for PSIRTs (Path B)

The facade pattern ensures existing API consumers continue to work
without modification.

Original design (monolithic):
    VulnerabilityScanner -> (database + LLM logic inline)

New design (decoupled):
    VulnerabilityScanner (facade)
        └── ScanRouter (orchestration)
            ├── DatabaseScanner (Path A: fast)
            └── AIAnalyzer (Path B: LLM)

Public Interface (stable):
- scan_device(platform, version, ...) -> Dict
- analyze_psirt(summary, platform, ...) -> Dict
- get_vulnerability_details(vuln_id) -> Dict
"""
from typing import List, Dict, Optional
from datetime import datetime
import logging

from .scan_router import ScanRouter, get_router
from .db_scanner import DatabaseScanner
from .ai_analyzer import AIAnalyzer

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """
    Dual-path vulnerability scanner (Facade)

    This class maintains backwards compatibility with existing code
    while delegating to the new decoupled modules.

    Responsibilities (now delegated):
    - Route requests to database or LLM path -> ScanRouter
    - Query database for version + label matches -> DatabaseScanner
    - Fallback to SEC-8B for unknown advisories -> AIAnalyzer
    - Cache high-confidence LLM results -> AIAnalyzer
    - Group results by severity -> DatabaseScanner

    Usage:
        scanner = get_scanner(db_path="vulnerability_db.sqlite")
        result = scanner.scan_device("IOS-XE", "17.3.5")
    """

    def __init__(self, db_path: str, sec8b_analyzer=None):
        """
        Initialize scanner with database and LLM analyzer.

        Args:
            db_path: Path to SQLite vulnerability database
            sec8b_analyzer: SEC8BAnalyzer instance (optional, will create if None)
        """
        self.db_path = db_path

        # Initialize the router which manages both scanning paths
        self._router = ScanRouter(db_path, sec8b_analyzer)

        # Expose SEC-8B for backwards compatibility
        self.sec8b = self._router.ai_analyzer.sec8b

        logger.info(f"VulnerabilityScanner (facade) initialized with database: {db_path}")

    # =========================================================================
    # PATH A: DATABASE SCAN (delegated to ScanRouter -> DatabaseScanner)
    # =========================================================================

    def scan_device(
        self,
        platform: str,
        version: str,
        labels: Optional[List[str]] = None,
        hardware_model: Optional[str] = None,
        severity_filter: Optional[List[int]] = None,
        limit: Optional[int] = None,
        offset: int = 0
    ) -> Dict:
        """
        Fast scan: Query database for matching vulnerabilities.

        Delegated to: ScanRouter -> DatabaseScanner

        Process:
        1. Query all bugs for platform
        2. Filter by version (string matching in affected_versions_raw)
        3. Filter by hardware model if provided (40-60% reduction)
        4. Filter by labels/features if provided (feature-aware)
        5. Group by severity (Critical/High vs Medium/Low)
        6. Return sorted results

        Args:
            platform: Device platform (e.g., "IOS-XE")
            version: Device software version (e.g., "17.3.5")
            labels: Optional list of configured feature labels
            hardware_model: Optional hardware model (e.g., "Cat9200")
            severity_filter: Optional list of severity levels to include
            limit: Optional max results to return
            offset: Pagination offset

        Returns:
            Scan result dict with vulnerabilities and metadata

        Performance target: <10ms for typical scan (10-50 results)
        """
        return self._router.scan_device(
            platform=platform,
            version=version,
            labels=labels,
            hardware_model=hardware_model,
            severity_filter=severity_filter,
            limit=limit,
            offset=offset
        )

    # =========================================================================
    # PATH B: LLM ANALYSIS (delegated to ScanRouter -> AIAnalyzer)
    # =========================================================================

    def analyze_psirt(
        self,
        summary: str,
        platform: str,
        advisory_id: Optional[str] = None
    ) -> Dict:
        """
        Analyze PSIRT: Check database cache, fallback to SEC-8B.

        Delegated to: ScanRouter -> AIAnalyzer

        Process:
        1. If advisory_id provided, check database cache
        2. Cache hit: Return database result (fast)
        3. Cache miss: Run SEC-8B inference (slow)
        4. If high confidence (>=0.75), cache result in database
        5. Return analysis with source indicator

        Args:
            summary: PSIRT summary text
            platform: Platform (e.g., "IOS-XE")
            advisory_id: Optional advisory ID (e.g., "cisco-sa-iosxe-ssh-dos")

        Returns:
            Analysis result dict with labels, confidence, and source

        Performance:
        - Database hit: <10ms
        - LLM inference: ~3400ms (8-bit SEC-8B)
        """
        return self._router.analyze_psirt(
            summary=summary,
            platform=platform,
            advisory_id=advisory_id
        )

    # =========================================================================
    # UTILITY METHODS (delegated)
    # =========================================================================

    def get_vulnerability_details(self, vuln_id: str) -> Optional[Dict]:
        """
        Get full details for a specific vulnerability.

        Delegated to: ScanRouter -> DatabaseScanner

        Used to expand collapsed Medium/Low results.

        Args:
            vuln_id: Vulnerability ID

        Returns:
            Full vulnerability dict or None if not found
        """
        return self._router.get_vulnerability_details(vuln_id)

    # =========================================================================
    # FUTURE: UNIFIED OPERATIONS
    # =========================================================================

    def scan_all(
        self,
        platform: str,
        version: str,
        labels: Optional[List[str]] = None,
        hardware_model: Optional[str] = None,
        include_psirt_analysis: bool = False,
        psirt_summaries: Optional[List[Dict]] = None
    ) -> Dict:
        """
        Unified scanning: Combine database scan with optional PSIRT analysis.

        Delegated to: ScanRouter

        Args:
            platform: Device platform
            version: Device software version
            labels: Optional feature labels
            hardware_model: Optional hardware model
            include_psirt_analysis: Whether to include PSIRT analysis
            psirt_summaries: List of PSIRT summaries to analyze

        Returns:
            Combined scan result
        """
        return self._router.scan_all(
            platform=platform,
            version=version,
            labels=labels,
            hardware_model=hardware_model,
            include_psirt_analysis=include_psirt_analysis,
            psirt_summaries=psirt_summaries
        )

    # =========================================================================
    # DIRECT ACCESS TO SUBSYSTEMS (for advanced usage)
    # =========================================================================

    @property
    def router(self) -> ScanRouter:
        """Get the underlying ScanRouter for direct access."""
        return self._router

    @property
    def db_scanner(self) -> DatabaseScanner:
        """Get the DatabaseScanner for direct database operations."""
        return self._router.db_scanner

    @property
    def ai_analyzer(self) -> AIAnalyzer:
        """Get the AIAnalyzer for direct LLM operations."""
        return self._router.ai_analyzer

    def health_check(self) -> Dict:
        """
        Check health of all scanning subsystems.

        Returns:
            Health status dict for monitoring
        """
        return self._router.health_check()


# Global singleton instance
_scanner_instance = None


def get_scanner(db_path: str = None, sec8b_analyzer=None) -> VulnerabilityScanner:
    """
    Get or create VulnerabilityScanner singleton.

    Args:
        db_path: Path to SQLite database (required on first call)
        sec8b_analyzer: Optional SEC8BAnalyzer instance

    Returns:
        VulnerabilityScanner instance
    """
    global _scanner_instance

    if _scanner_instance is None:
        if db_path is None:
            raise ValueError("db_path required on first call to get_scanner()")

        _scanner_instance = VulnerabilityScanner(db_path, sec8b_analyzer)

    return _scanner_instance


# Export symbols for backwards compatibility
__all__ = [
    'VulnerabilityScanner',
    'get_scanner',
    'ScanRouter',
    'DatabaseScanner',
    'AIAnalyzer'
]
